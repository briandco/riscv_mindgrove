#![doc = "Peripheral access API for SECURE_IOT microcontrollers (generated using svd2rust v0.33.4 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.33.4/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 7;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
pub mod result;
use result::Result;
#[cfg(feature = "rt")]
extern "C" {
    fn GPIO0();
    fn GPIO1();
    fn GPIO2();
    fn GPIO3();
    fn GPIO4();
    fn GPIO5();
    fn GPIO6();
    fn GPIO7();
    fn GPIO8();
    fn GPIO9();
    fn GPIO10();
    fn GPIO11();
    fn GPIO12();
    fn GPIO13();
    fn GPIO14();
    fn GPIO15();
    fn GPIO16();
    fn GPIO17();
    fn GPIO18();
    fn GPIO19();
    fn GPIO20();
    fn GPIO21();
    fn GPIO22();
    fn GPIO23();
    fn GPIO24();
    fn GPIO25();
    fn GPIO26();
    fn GPIO27();
    fn GPIO28();
    fn GPIO29();
    fn GPIO30();
    fn GPIO31();
    fn PWM7();
    fn PWM6();
    fn PWM5();
    fn PWM4();
    fn PWM3();
    fn PWM2();
    fn PWM1();
    fn PWM0();
    fn GPTIMER0();
    fn GPTIMER1();
    fn GPTIMER2();
    fn GPTIMER3();
    fn I2C0();
    fn I2C1();
    fn UART0();
    fn UART1();
    fn UART2();
    fn QUADSPI1();
    fn QUADSPI1_READY();
    fn QUADSPI0();
    fn QUADSPI0_READY();
    fn SPI3();
    fn SPI2();
    fn SPI1();
    fn SPI0();
}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 58] = [
    Vector { _reserved: 0 },
    Vector { _handler: GPIO0 },
    Vector { _handler: GPIO1 },
    Vector { _handler: GPIO2 },
    Vector { _handler: GPIO3 },
    Vector { _handler: GPIO4 },
    Vector { _handler: GPIO5 },
    Vector { _handler: GPIO6 },
    Vector { _handler: GPIO7 },
    Vector { _handler: GPIO8 },
    Vector { _handler: GPIO9 },
    Vector { _handler: GPIO10 },
    Vector { _handler: GPIO11 },
    Vector { _handler: GPIO12 },
    Vector { _handler: GPIO13 },
    Vector { _handler: GPIO14 },
    Vector { _handler: GPIO15 },
    Vector { _handler: GPIO16 },
    Vector { _handler: GPIO17 },
    Vector { _handler: GPIO18 },
    Vector { _handler: GPIO19 },
    Vector { _handler: GPIO20 },
    Vector { _handler: GPIO21 },
    Vector { _handler: GPIO22 },
    Vector { _handler: GPIO23 },
    Vector { _handler: GPIO24 },
    Vector { _handler: GPIO25 },
    Vector { _handler: GPIO26 },
    Vector { _handler: GPIO27 },
    Vector { _handler: GPIO28 },
    Vector { _handler: GPIO29 },
    Vector { _handler: GPIO30 },
    Vector { _handler: GPIO31 },
    Vector { _handler: PWM7 },
    Vector { _handler: PWM6 },
    Vector { _handler: PWM5 },
    Vector { _handler: PWM4 },
    Vector { _handler: PWM3 },
    Vector { _handler: PWM2 },
    Vector { _handler: PWM1 },
    Vector { _handler: PWM0 },
    Vector { _handler: GPTIMER0 },
    Vector { _handler: GPTIMER1 },
    Vector { _handler: GPTIMER2 },
    Vector { _handler: GPTIMER3 },
    Vector { _handler: I2C0 },
    Vector { _handler: I2C1 },
    Vector { _handler: UART0 },
    Vector { _handler: UART1 },
    Vector { _handler: UART2 },
    Vector { _handler: QUADSPI1 },
    Vector {
        _handler: QUADSPI1_READY,
    },
    Vector { _handler: QUADSPI0 },
    Vector {
        _handler: QUADSPI0_READY,
    },
    Vector { _handler: SPI3 },
    Vector { _handler: SPI2 },
    Vector { _handler: SPI1 },
    Vector { _handler: SPI0 },
];
#[doc = r"Enumeration of all the interrupts."]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum Interrupt {
    #[doc = "1 - GPIO0"]
    GPIO0 = 1,
    #[doc = "2 - GPIO1"]
    GPIO1 = 2,
    #[doc = "3 - GPIO2"]
    GPIO2 = 3,
    #[doc = "4 - GPIO3"]
    GPIO3 = 4,
    #[doc = "5 - GPIO4"]
    GPIO4 = 5,
    #[doc = "6 - GPIO5"]
    GPIO5 = 6,
    #[doc = "7 - GPIO6"]
    GPIO6 = 7,
    #[doc = "8 - GPIO7"]
    GPIO7 = 8,
    #[doc = "9 - GPIO8"]
    GPIO8 = 9,
    #[doc = "10 - GPIO9"]
    GPIO9 = 10,
    #[doc = "11 - GPIO10"]
    GPIO10 = 11,
    #[doc = "12 - GPIO11"]
    GPIO11 = 12,
    #[doc = "13 - GPIO12"]
    GPIO12 = 13,
    #[doc = "14 - GPIO13"]
    GPIO13 = 14,
    #[doc = "15 - GPIO14"]
    GPIO14 = 15,
    #[doc = "16 - GPIO15"]
    GPIO15 = 16,
    #[doc = "17 - GPIO16"]
    GPIO16 = 17,
    #[doc = "18 - GPIO17"]
    GPIO17 = 18,
    #[doc = "19 - GPIO18"]
    GPIO18 = 19,
    #[doc = "20 - GPIO19"]
    GPIO19 = 20,
    #[doc = "21 - GPIO20"]
    GPIO20 = 21,
    #[doc = "22 - GPIO21"]
    GPIO21 = 22,
    #[doc = "23 - GPIO22"]
    GPIO22 = 23,
    #[doc = "24 - GPIO23"]
    GPIO23 = 24,
    #[doc = "25 - GPIO24"]
    GPIO24 = 25,
    #[doc = "26 - GPIO25"]
    GPIO25 = 26,
    #[doc = "27 - GPIO26"]
    GPIO26 = 27,
    #[doc = "28 - GPIO27"]
    GPIO27 = 28,
    #[doc = "29 - GPIO28"]
    GPIO28 = 29,
    #[doc = "30 - GPIO29"]
    GPIO29 = 30,
    #[doc = "31 - GPIO30"]
    GPIO30 = 31,
    #[doc = "32 - GPIO31"]
    GPIO31 = 32,
    #[doc = "33 - PWM7"]
    PWM7 = 33,
    #[doc = "34 - PWM6"]
    PWM6 = 34,
    #[doc = "35 - PWM5"]
    PWM5 = 35,
    #[doc = "36 - PWM4"]
    PWM4 = 36,
    #[doc = "37 - PWM3"]
    PWM3 = 37,
    #[doc = "38 - PWM2"]
    PWM2 = 38,
    #[doc = "39 - PWM1"]
    PWM1 = 39,
    #[doc = "40 - PWM0"]
    PWM0 = 40,
    #[doc = "41 - GPTIMER0"]
    GPTIMER0 = 41,
    #[doc = "42 - GPTIMER1"]
    GPTIMER1 = 42,
    #[doc = "43 - GPTIMER2"]
    GPTIMER2 = 43,
    #[doc = "44 - GPTIMER3"]
    GPTIMER3 = 44,
    #[doc = "45 - I2C0"]
    I2C0 = 45,
    #[doc = "46 - I2C1"]
    I2C1 = 46,
    #[doc = "47 - UART0"]
    UART0 = 47,
    #[doc = "48 - UART1"]
    UART1 = 48,
    #[doc = "49 - UART2"]
    UART2 = 49,
    #[doc = "50 - QUADSPI1"]
    QUADSPI1 = 50,
    #[doc = "51 - QUADSPI1_READY"]
    QUADSPI1_READY = 51,
    #[doc = "52 - QUADSPI0"]
    QUADSPI0 = 52,
    #[doc = "53 - QUADSPI0_READY"]
    QUADSPI0_READY = 53,
    #[doc = "54 - SPI3"]
    SPI3 = 54,
    #[doc = "55 - SPI2"]
    SPI2 = 55,
    #[doc = "56 - SPI1"]
    SPI1 = 56,
    #[doc = "57 - SPI0"]
    SPI0 = 57,
}
/// Trait for enums of target-specific external interrupt numbers.
///
/// This trait should be implemented by a peripheral access crate (PAC)
/// on its enum of available external interrupts for a specific device.
/// Each variant must convert to a `u16` of its interrupt number.
///
/// # Safety
///
/// * This trait must only be implemented on a PAC of a RISC-V target.
/// * This trait must only be implemented on enums of external interrupts.
/// * Each enum variant must represent a distinct value (no duplicates are permitted),
/// * Each enum variant must always return the same value (do not change at runtime).
/// * All the interrupt numbers must be less than or equal to `MAX_INTERRUPT_NUMBER`.
/// * `MAX_INTERRUPT_NUMBER` must coincide with the highest allowed interrupt number.
pub unsafe trait InterruptNumber: Copy {
    /// Highest number assigned to an interrupt source.
    const MAX_INTERRUPT_NUMBER: u16;

    /// Converts an interrupt source to its corresponding number.
    fn number(self) -> u16;

    /// Tries to convert a number to a valid interrupt source.
    /// If the conversion fails, it returns an error with the number back.
    fn from_number(value: u16) -> Result<Self>;
}

#[doc = "Pulse-width modulation number 0"]
pub struct Pwm0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pwm0 {}
impl Pwm0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x0003_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pwm0 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pwm0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwm0").finish()
    }
}
#[doc = "Pulse-width modulation number 0"]
pub mod pwm0;
#[doc = "Pulse Width Modulator"]
pub struct Pwm1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pwm1 {}
impl Pwm1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x0003_0100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pwm1 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pwm1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwm1").finish()
    }
}
#[doc = "Pulse Width Modulator"]
pub use self::pwm0 as pwm1;
#[doc = "Pulse Width Modulator"]
pub struct Pwm2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pwm2 {}
impl Pwm2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x0003_0200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pwm2 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pwm2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwm2").finish()
    }
}
#[doc = "Pulse Width Modulator"]
pub use self::pwm0 as pwm2;
#[doc = "Pulse Width Modulator"]
pub struct Pwm3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pwm3 {}
impl Pwm3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x0003_0300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pwm3 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pwm3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwm3").finish()
    }
}
#[doc = "Pulse Width Modulator"]
pub use self::pwm0 as pwm3;
#[doc = "Pulse Width Modulator"]
pub struct Pwm4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pwm4 {}
impl Pwm4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x0003_0400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pwm4 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pwm4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwm4").finish()
    }
}
#[doc = "Pulse Width Modulator"]
pub use self::pwm0 as pwm4;
#[doc = "Pulse Width Modulator"]
pub struct Pwm5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pwm5 {}
impl Pwm5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x0003_0500 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pwm5 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pwm5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwm5").finish()
    }
}
#[doc = "Pulse Width Modulator"]
pub use self::pwm0 as pwm5;
#[doc = "Pulse Width Modulator"]
pub struct Pwm6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pwm6 {}
impl Pwm6 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x0003_0600 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pwm6 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pwm6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwm6").finish()
    }
}
#[doc = "Pulse Width Modulator"]
pub use self::pwm0 as pwm6;
#[doc = "Pulse Width Modulator"]
pub struct Pwm7 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pwm7 {}
impl Pwm7 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x0003_0700 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pwm7 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pwm7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwm7").finish()
    }
}
#[doc = "Pulse Width Modulator"]
pub use self::pwm0 as pwm7;
#[doc = "General purpose timer"]
pub struct Gptimer0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gptimer0 {}
impl Gptimer0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gptimer0::RegisterBlock = 0x0004_4200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gptimer0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gptimer0 {
    type Target = gptimer0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gptimer0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gptimer0").finish()
    }
}
#[doc = "General purpose timer"]
pub mod gptimer0;
#[doc = "General Purpose Timer"]
pub struct Gptimer1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gptimer1 {}
impl Gptimer1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gptimer0::RegisterBlock = 0x0004_4220 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gptimer0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gptimer1 {
    type Target = gptimer0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gptimer1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gptimer1").finish()
    }
}
#[doc = "General Purpose Timer"]
pub use self::gptimer0 as gptimer1;
#[doc = "General Purpose Timer"]
pub struct Gptimer2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gptimer2 {}
impl Gptimer2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gptimer0::RegisterBlock = 0x0004_4240 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gptimer0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gptimer2 {
    type Target = gptimer0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gptimer2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gptimer2").finish()
    }
}
#[doc = "General Purpose Timer"]
pub use self::gptimer0 as gptimer2;
#[doc = "General Purpose Timer"]
pub struct Gptimer3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gptimer3 {}
impl Gptimer3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gptimer0::RegisterBlock = 0x0004_4260 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gptimer0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gptimer3 {
    type Target = gptimer0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gptimer3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gptimer3").finish()
    }
}
#[doc = "General Purpose Timer"]
pub use self::gptimer0 as gptimer3;
#[doc = "Core Local Interrupt Controller"]
pub struct Clint0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Clint0 {}
impl Clint0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const clint0::RegisterBlock = 0x0200_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const clint0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Clint0 {
    type Target = clint0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Clint0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Clint0").finish()
    }
}
#[doc = "Core Local Interrupt Controller"]
pub mod clint0;
#[doc = "Universal asynchronous receiver and transmitter"]
pub struct Uart0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart0 {}
impl Uart0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x0001_1300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart0 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart0").finish()
    }
}
#[doc = "Universal asynchronous receiver and transmitter"]
pub mod uart0;
#[doc = "Universal asynchronous receiver and transmitter"]
pub struct Uart1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart1 {}
impl Uart1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x0001_1400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart1 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart1").finish()
    }
}
#[doc = "Universal asynchronous receiver and transmitter"]
pub use self::uart0 as uart1;
#[doc = "Universal asynchronous receiver and transmitter"]
pub struct Uart2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart2 {}
impl Uart2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x0001_1500 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart2 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart2").finish()
    }
}
#[doc = "Universal asynchronous receiver and transmitter"]
pub use self::uart0 as uart2;
#[doc = "I2C communication peripheral"]
pub struct I2c0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2c0 {}
impl I2c0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2c0::RegisterBlock = 0x0004_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2c0 {
    type Target = i2c0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2c0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2c0").finish()
    }
}
#[doc = "I2C communication peripheral"]
pub mod i2c0;
#[doc = "I2C communication peripheral"]
pub struct I2c1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2c1 {}
impl I2c1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2c0::RegisterBlock = 0x0004_4100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2c1 {
    type Target = i2c0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2c1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2c1").finish()
    }
}
#[doc = "I2C communication peripheral"]
pub use self::i2c0 as i2c1;
#[doc = "Watchdog Timer"]
pub struct Wdt0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Wdt0 {}
impl Wdt0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wdt0::RegisterBlock = 0x0004_0400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wdt0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Wdt0 {
    type Target = wdt0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Wdt0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Wdt0").finish()
    }
}
#[doc = "Watchdog Timer"]
pub mod wdt0;
#[doc = "Pinmux which selects between GPIO and PWM."]
pub struct Pinmux0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pinmux0 {}
impl Pinmux0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pinmux0::RegisterBlock = 0x0004_0300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pinmux0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pinmux0 {
    type Target = pinmux0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pinmux0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pinmux0").finish()
    }
}
#[doc = "Pinmux which selects between GPIO and PWM."]
pub mod pinmux0;
#[doc = "General purpose IO. 32 GPIOs are available"]
pub struct Gpio {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpio {}
impl Gpio {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio::RegisterBlock = 0x0004_0200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpio {
    type Target = gpio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpio {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio").finish()
    }
}
#[doc = "General purpose IO. 32 GPIOs are available"]
pub mod gpio;
#[doc = "AES algorithm accelerator"]
pub struct Aes {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Aes {}
impl Aes {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const aes::RegisterBlock = 0x0400_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aes::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Aes {
    type Target = aes::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Aes {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Aes").finish()
    }
}
#[doc = "AES algorithm accelerator"]
pub mod aes;
#[doc = "SHA256 algorithm accelerator"]
pub struct Sha256 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Sha256 {}
impl Sha256 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const sha256::RegisterBlock = 0x0300_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const sha256::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Sha256 {
    type Target = sha256::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Sha256 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sha256").finish()
    }
}
#[doc = "SHA256 algorithm accelerator"]
pub mod sha256;
#[doc = "RSA crypto accelerator"]
pub struct Rsa {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rsa {}
impl Rsa {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rsa::RegisterBlock = 0x0500_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rsa::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rsa {
    type Target = rsa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rsa {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rsa").finish()
    }
}
#[doc = "RSA crypto accelerator"]
pub mod rsa;
#[doc = "SPI communication peripheral"]
pub struct Spi0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spi0 {}
impl Spi0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spi0::RegisterBlock = 0x0002_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spi0 {
    type Target = spi0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spi0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spi0").finish()
    }
}
#[doc = "SPI communication peripheral"]
pub mod spi0;
#[doc = "SPI communication peripheral"]
pub struct Spi1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spi1 {}
impl Spi1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spi0::RegisterBlock = 0x0002_0100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spi1 {
    type Target = spi0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spi1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spi1").finish()
    }
}
#[doc = "SPI communication peripheral"]
pub use self::spi0 as spi1;
#[doc = "SPI communication peripheral"]
pub struct Spi2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spi2 {}
impl Spi2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spi0::RegisterBlock = 0x0002_0200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spi2 {
    type Target = spi0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spi2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spi2").finish()
    }
}
#[doc = "SPI communication peripheral"]
pub use self::spi0 as spi2;
#[doc = "SPI communication peripheral"]
pub struct Spi3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spi3 {}
impl Spi3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spi0::RegisterBlock = 0x0002_0300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spi3 {
    type Target = spi0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spi3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spi3").finish()
    }
}
#[doc = "SPI communication peripheral"]
pub use self::spi0 as spi3;
#[doc = "QuadSPI Interface 0"]
pub struct Quadspi0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Quadspi0 {}
impl Quadspi0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const quadspi0::RegisterBlock = 0x0004_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const quadspi0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Quadspi0 {
    type Target = quadspi0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Quadspi0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Quadspi0").finish()
    }
}
#[doc = "QuadSPI Interface 0"]
pub mod quadspi0;
#[doc = "QuadSPI Interface 1"]
pub struct Quadspi1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Quadspi1 {}
impl Quadspi1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const quadspi0::RegisterBlock = 0x0004_0100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const quadspi0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Quadspi1 {
    type Target = quadspi0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Quadspi1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Quadspi1").finish()
    }
}
#[doc = "QuadSPI Interface 1"]
pub use self::quadspi0 as quadspi1;
#[doc = "Instruction Trace"]
pub struct Itrace {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Itrace {}
impl Itrace {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const itrace::RegisterBlock = 0x0006_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const itrace::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Itrace {
    type Target = itrace::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Itrace {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Itrace").finish()
    }
}
#[doc = "Instruction Trace"]
pub mod itrace;
#[doc = "The RAM sink where all the trace packets are stored"]
pub struct ItraceRam {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ItraceRam {}
impl ItraceRam {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const itrace_ram::RegisterBlock = 0x0006_0100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const itrace_ram::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ItraceRam {
    type Target = itrace_ram::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ItraceRam {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ItraceRam").finish()
    }
}
#[doc = "The RAM sink where all the trace packets are stored"]
pub mod itrace_ram;
#[doc = "Platform Level Interrupt Controller"]
pub struct Plic0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Plic0 {}
impl Plic0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const plic0::RegisterBlock = 0x0c00_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const plic0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Plic0 {
    type Target = plic0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Plic0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Plic0").finish()
    }
}
#[doc = "Platform Level Interrupt Controller"]
pub mod plic0;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "PWM0"]
    pub pwm0: Pwm0,
    #[doc = "PWM1"]
    pub pwm1: Pwm1,
    #[doc = "PWM2"]
    pub pwm2: Pwm2,
    #[doc = "PWM3"]
    pub pwm3: Pwm3,
    #[doc = "PWM4"]
    pub pwm4: Pwm4,
    #[doc = "PWM5"]
    pub pwm5: Pwm5,
    #[doc = "PWM6"]
    pub pwm6: Pwm6,
    #[doc = "PWM7"]
    pub pwm7: Pwm7,
    #[doc = "GPTIMER0"]
    pub gptimer0: Gptimer0,
    #[doc = "GPTIMER1"]
    pub gptimer1: Gptimer1,
    #[doc = "GPTIMER2"]
    pub gptimer2: Gptimer2,
    #[doc = "GPTIMER3"]
    pub gptimer3: Gptimer3,
    #[doc = "CLINT0"]
    pub clint0: Clint0,
    #[doc = "UART0"]
    pub uart0: Uart0,
    #[doc = "UART1"]
    pub uart1: Uart1,
    #[doc = "UART2"]
    pub uart2: Uart2,
    #[doc = "I2C0"]
    pub i2c0: I2c0,
    #[doc = "I2C1"]
    pub i2c1: I2c1,
    #[doc = "WDT0"]
    pub wdt0: Wdt0,
    #[doc = "PINMUX0"]
    pub pinmux0: Pinmux0,
    #[doc = "GPIO"]
    pub gpio: Gpio,
    #[doc = "AES"]
    pub aes: Aes,
    #[doc = "SHA256"]
    pub sha256: Sha256,
    #[doc = "RSA"]
    pub rsa: Rsa,
    #[doc = "SPI0"]
    pub spi0: Spi0,
    #[doc = "SPI1"]
    pub spi1: Spi1,
    #[doc = "SPI2"]
    pub spi2: Spi2,
    #[doc = "SPI3"]
    pub spi3: Spi3,
    #[doc = "QUADSPI0"]
    pub quadspi0: Quadspi0,
    #[doc = "QUADSPI1"]
    pub quadspi1: Quadspi1,
    #[doc = "ITRACE"]
    pub itrace: Itrace,
    #[doc = "ITRACE_RAM"]
    pub itrace_ram: ItraceRam,
    #[doc = "PLIC0"]
    pub plic0: Plic0,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            pwm0: Pwm0::steal(),
            pwm1: Pwm1::steal(),
            pwm2: Pwm2::steal(),
            pwm3: Pwm3::steal(),
            pwm4: Pwm4::steal(),
            pwm5: Pwm5::steal(),
            pwm6: Pwm6::steal(),
            pwm7: Pwm7::steal(),
            gptimer0: Gptimer0::steal(),
            gptimer1: Gptimer1::steal(),
            gptimer2: Gptimer2::steal(),
            gptimer3: Gptimer3::steal(),
            clint0: Clint0::steal(),
            uart0: Uart0::steal(),
            uart1: Uart1::steal(),
            uart2: Uart2::steal(),
            i2c0: I2c0::steal(),
            i2c1: I2c1::steal(),
            wdt0: Wdt0::steal(),
            pinmux0: Pinmux0::steal(),
            gpio: Gpio::steal(),
            aes: Aes::steal(),
            sha256: Sha256::steal(),
            rsa: Rsa::steal(),
            spi0: Spi0::steal(),
            spi1: Spi1::steal(),
            spi2: Spi2::steal(),
            spi3: Spi3::steal(),
            quadspi0: Quadspi0::steal(),
            quadspi1: Quadspi1::steal(),
            itrace: Itrace::steal(),
            itrace_ram: ItraceRam::steal(),
            plic0: Plic0::steal(),
        }
    }
}
